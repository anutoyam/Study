Swift란?
컴파일언어 -> 1. 실행전 소스코드를 컴파일하여 기계어로 변환 후 해당 파일을 실행한다.
              2. 이미 기계어로 변환된 것을 실행하므로 비교적 빠름.
              3. 문법적 제약이 일반적으로 많음
              4. 운영체제에 따라 다르게 작업해야 함.

콘솔로그 & 보간법

1. "안녕하세요! 저는 \(age) 살입니다."
== "안녕하세요! 저는 10 살입니다."
2. print("안녕하세요! 저는 \(age)살 입니다.")
//////////////////
상수 변수 선언법

상수
let 이름 : 타입 = 값
변수
var 이름 : 타입 = 값

let content : String = "후에 변경이 불가능"
var content : String = "후에 변경이 가능"
///////////////////////
데이터 타입
Int, UInt, Float, Double, Character(한글자), String

//////////
Any,AnyObject,nil

Any - Swift의 모든 타입을 지칭하는 키워드
AnyObject - 모든 클래스 타입을 지칭하는 프로토콜
nil - 없음을 의미하는 키워드

var someAny : Any = 100
someAny = "어떤 타입도 수용 가능합니다."
someAny = 123.12

let somDouble : Double = someAny << 오류 발생 - 애니 타입의 값은 넣을 수 없다.

class SomeClass{}
var someAnyObject : AnyObject = SomeClass()
someAnyObject = 123.12

someAny = nil
someAnyObject = nil

//////////////
컬렉션 타입 - Array, Dictionary, Set

Array - 순서가 있는 리스트 컬렉션
Dictionary - 키와 값의 쌍으로 이루어진 컬렉션
Set - 순서가 없고, 멤버가 유일한 컬렉션

>> Array
var integers : Array<Int> = Array<Int>()
integers.append(1) //[1]
integers.append(100) //[1,100]

integers.contains(100) //true
integers.contains(99) //false

integers.remove(at: 0) // 1을 지움
integers.removeLast() // 100을 지움
integers.removeAll() // 모두 지움

integers.count // 0

*Array<Double> [Double] 은 같은 표현*
var doubles : Array<Double> = [Double]()
var strings : [String] = [String]()
[]는 빈 Array 생성
var characters : [Character] = []

let을 사용하여 Array를 선언하면 불변  Array
let immutableArray = [1,2,3]
>>
immutableArray.append(4) - 안됨
immutableArray.removeAll() - 안됨

>> Dictionary
Key가 String 타입이고 Value가 Any인 빈 Dictionary todtjd
var anyDictionary : Dictionary<String, Any> = [String : Any]()
anyDictionary["someKey"] = "value"
anyDictionary["anotherKey"] = 100

anyDictionary >> ["someKey" : "value", "anotherKey" : "100"]

anyDictionary["someKey"] = "dictionary"
anyDictionary >> ["someKey" : "dictionary", "anotherKey" : "100"]

anyDictionary.removeValue(forKey : "anotherKey")
anyDictionary["someKey"] = nil

anyDictionary  >> [:]

let emptyDictionary : [String : String] = [:]
let initializedDictionary : [String : String] = ["name" : "MH", "gender" : "male"]

>> Set
빈 Int Set 생성
var integerSet : Set<Int> = Set<Int>()
integerSet.insert(1)
integerSet.insert(100)
integerSet.insert(99)
integerSet.insert(99)
integerSet.insert(99)

integerSet >> {100,99,1} 중복은 허용하지 않음
 
let setA : Set<Int> = [1,2,3,4,5]
let setB : Set<Int> = [3,4,5,6,7]

let union : Set<Int> = setA.union(setB) >> {2,4,5,6,3,7,1}
let sortedUnion : [Int] = union.sorted() >> {1,2,3,4,5,6,7}
let intersection : Set<Int> = setA.intersection(setB) >> {5,3,4} 교집합
let subtracting : Set<Int> = setA.subtracting(setB) >> {2,1} 차집합

/////////
function
반환값이 있는 함수
func 함수이름(매개변수1이름 : 매개변수1타입, 매개변수2이름: 매개변수2타입 ...) -> 반환타입 {
    함수 구현부
    return 반환값
}

func sum(a: Int, b : Int) -> Int {
    return a + b
}

반환값이 없는 함수
func 함수이름(매개변수1이 : 매개변수1타입, 매개변수2이름 : 매개변수2타입 ...) -> Void {
    함수 구현부
    return
}

func printMyName(name : String) -> Void {
    print(name)
}

매개변수와 반환값 전부 없을수도있다
func hello() -> print{"hello"}

기본값을 갖는 매개변수는 매개변수 목록 중에 뒤쪽에 위치하는 것이 좋다.
func 함수이름(매개변수1이름 : 매개변수1타입, 매개변수2이름 : 매개변수2타입 = 매개변수 기본값...) -> 반환타입 {
    함수 구현부
    return 반환값
}

func greeting(friend : String, me : String = "MH"){
    print("Hello \(friend)! I'm \(me)")
}

함수 내부에서 전달인자를 사용할 때에는 매개변수 이름을 사용합니다.
함수이름이 greeting 뿐만 아니라 to, from 까지 합쳐졌기때문에 greeting이 중복되도 작동함.
func greeting(to friend : String, from me : String){
    print("Hello \(friend)! I'm \(me)")
}

전달 받을 값의 개수를 알기 어려울 때 가변 매개변수를 사용한다.
가변 매개변수는 함수당 하나만 가질 수 있다.
func 함수이름(매개변수1이름 : 매개변수1타입, 전달인자 레이블 : 매개변수2이름 : 매개변수2타입...) -> 반환타입 {
    함수 구현부
    return
}

func sayHelloToFriends(me : String, friends : String...) -> String{
    return "Hello \(friend)! I'm \(me)!"
}

print(sayHelloToFriends(me : "MH", friends : "A","B","C"))